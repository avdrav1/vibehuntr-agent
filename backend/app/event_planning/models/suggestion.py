"""Event suggestion data model."""

from dataclasses import dataclass, field
from datetime import timedelta, datetime
from typing import Dict, Optional
import json

from app.event_planning.models.event import Location


@dataclass
class EventSuggestion:
    """Represents an event suggestion generated by the recommendation engine."""
    
    id: str
    activity_type: str
    location: Location
    estimated_duration: timedelta
    estimated_cost_per_person: float
    description: str
    consensus_score: float = 0.0
    member_compatibility: Dict[str, float] = field(default_factory=dict)
    available_start_date: Optional[datetime] = None  # When this suggestion is available from
    available_end_date: Optional[datetime] = None    # When this suggestion is available until
    
    def validate(self) -> None:
        """Validate the event suggestion data."""
        if not self.id:
            raise ValueError("id cannot be empty")
        if not self.activity_type:
            raise ValueError("activity_type cannot be empty")
        if self.estimated_cost_per_person < 0:
            raise ValueError("estimated_cost_per_person cannot be negative")
        if not 0 <= self.consensus_score <= 1:
            raise ValueError("consensus_score must be between 0 and 1")
        for user_id, score in self.member_compatibility.items():
            if not 0 <= score <= 1:
                raise ValueError(f"compatibility score for {user_id} must be between 0 and 1")
        
        self.location.validate()
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "id": self.id,
            "activity_type": self.activity_type,
            "location": self.location.to_dict(),
            "estimated_duration": self.estimated_duration.total_seconds(),
            "estimated_cost_per_person": self.estimated_cost_per_person,
            "description": self.description,
            "consensus_score": self.consensus_score,
            "member_compatibility": self.member_compatibility,
            "available_start_date": self.available_start_date.isoformat() if self.available_start_date else None,
            "available_end_date": self.available_end_date.isoformat() if self.available_end_date else None,
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> "EventSuggestion":
        """Create from dictionary."""
        return cls(
            id=data["id"],
            activity_type=data["activity_type"],
            location=Location.from_dict(data["location"]),
            estimated_duration=timedelta(seconds=data["estimated_duration"]),
            estimated_cost_per_person=data["estimated_cost_per_person"],
            description=data["description"],
            consensus_score=data.get("consensus_score", 0.0),
            member_compatibility=data.get("member_compatibility", {}),
            available_start_date=datetime.fromisoformat(data["available_start_date"]) if data.get("available_start_date") else None,
            available_end_date=datetime.fromisoformat(data["available_end_date"]) if data.get("available_end_date") else None,
        )
    
    def to_json(self) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=2)
    
    @classmethod
    def from_json(cls, json_str: str) -> "EventSuggestion":
        """Create from JSON string."""
        return cls.from_dict(json.loads(json_str))

"""Property-based tests for agent invoker operations.

This module tests the correctness properties for agent invocation,
including session context provision and streaming token order.
"""

import sys
import os
from hypothesis import given, strategies as st, settings
from hypothesis.strategies import composite
import pytest
from typing import List, Dict, Any

# Add the project root to the path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from app.event_planning.agent_invoker import (
    invoke_agent_streaming,
    invoke_agent,
    AgentInvocationError
)


# Custom strategies for generating test data

@composite
def message_strategy(draw: st.DrawFn) -> dict:
    """Generate a valid message dictionary."""
    role = draw(st.sampled_from(["user", "assistant"]))
    content = draw(st.text(min_size=1, max_size=500))
    return {"role": role, "content": content}


@composite
def message_list_strategy(draw: st.DrawFn, min_size: int = 0, max_size: int = 20) -> list:
    """Generate a list of valid messages."""
    return draw(st.lists(message_strategy(), min_size=min_size, max_size=max_size))


# Mock implementations for testing
from unittest.mock import Mock, patch

def create_mock_streaming_response(response_text: str, should_fail: bool = False):
    """Create a mock streaming response generator."""
    if should_fail:
        raise Exception("Mock agent failure")
    
    # Yield response character by character as text items
    for char in response_text:
        yield {'type': 'text', 'content': char}


# Property Tests

# Feature: adk-playground-integration, Property 3: Session context provision
@given(
    st.text(min_size=1, max_size=50).filter(lambda x: len(x.strip()) > 0),
    st.text(min_size=1, max_size=200)
)
@settings(max_examples=100)
def test_property_3_session_context_provision(
    session_id: str,
    user_message: str
) -> None:
    """
    Feature: adk-playground-integration, Property 3: Session context provision
    
    For any agent invocation, the ADK session service should provide the complete
    chat history as context to the agent automatically.
    
    Validates: Requirements 3.3
    """
    with patch('app.event_planning.agent_invoker.invoke_agent_streaming') as mock_streaming:
        # Mock streaming response
        mock_streaming.return_value = iter([{'type': 'text', 'content': 'Test response'}])
        
        # Create a mock agent
        mock_agent = Mock()
        
        # Invoke agent (ADK session service handles history automatically)
        response = invoke_agent(mock_agent, user_message, session_id=session_id)
        
        # Verify streaming was called with the session_id
        mock_streaming.assert_called_once()
        call_args = mock_streaming.call_args
        # Check positional arguments
        assert call_args[0][0] == mock_agent  # agent argument
        assert call_args[0][1] == user_message  # message argument
        # Check that session_id is passed (either as positional or keyword)
        if len(call_args[0]) > 2:
            assert call_args[0][2] == session_id  # session_id as positional
        else:
            assert call_args[1].get('session_id') == session_id  # session_id as keyword
        
        # Verify response is returned
        assert response == "Test response"


# Feature: adk-playground-integration, Property 6: Streaming token order
@given(st.text(min_size=5, max_size=100))
@settings(max_examples=100)
def test_property_6_streaming_token_order(
    response_text: str
) -> None:
    """
    Feature: adk-playground-integration, Property 6: Streaming token order
    
    For any streaming response, tokens should be yielded in the order they are
    generated by the agent.
    
    Validates: Requirements 2.1
    """
    with patch('app.event_planning.agent_invoker._session_service') as mock_session_service, \
         patch('app.event_planning.agent_invoker.Runner') as mock_runner_class:
        
        # Mock session
        mock_session = Mock()
        mock_session.id = "test_session"
        mock_session_service.get_session_sync.return_value = mock_session
        
        # Create mock events with accumulated text (how ADK actually works)
        # Each event contains all text up to that point
        mock_events = []
        accumulated = ""
        for char in response_text:
            accumulated += char
            mock_event = Mock()
            mock_event.content = Mock()
            mock_part = Mock()
            mock_part.text = accumulated  # ADK sends accumulated text
            mock_event.content.parts = [mock_part]
            mock_event.function_calls = None
            mock_events.append(mock_event)
        
        # Mock runner
        mock_runner = Mock()
        mock_runner.run.return_value = iter(mock_events)
        mock_runner_class.return_value = mock_runner
        
        # Create a mock agent
        mock_agent = Mock()
        
        # Invoke agent with streaming
        streamed_items = []
        
        for item in invoke_agent_streaming(mock_agent, "Test message", session_id="test_session"):
            streamed_items.append(item)
        
        # Extract text content
        streamed_tokens = [item['content'] for item in streamed_items if item['type'] == 'text']
        
        # Verify tokens are in correct order
        reconstructed_response = "".join(streamed_tokens)
        assert reconstructed_response == response_text





# Additional property test: Error handling
@given(
    st.text(min_size=1, max_size=50).filter(lambda x: len(x.strip()) > 0),
    st.text(min_size=1, max_size=100)
)
@settings(max_examples=100)
def test_property_error_handling(
    session_id: str,
    user_message: str
) -> None:
    """
    For any agent invocation that fails, an AgentInvocationError should be raised
    with appropriate error information.
    
    Validates: Requirements 7.1, 7.2
    """
    with patch('app.event_planning.agent_invoker.invoke_agent_streaming') as mock_streaming:
        # Mock streaming to raise an error
        mock_streaming.side_effect = AgentInvocationError("Mock agent failure")
        
        # Create a mock agent
        mock_agent = Mock()
        
        # Verify that invoke_agent raises AgentInvocationError
        with pytest.raises(AgentInvocationError) as exc_info:
            invoke_agent(mock_agent, user_message, session_id=session_id)
        
        # Verify error message contains useful information
        error_message = str(exc_info.value)
        assert "Mock agent failure" in error_message


# Additional property test: New session handling
@given(st.text(min_size=1, max_size=100))
@settings(max_examples=100)
def test_property_new_session_handling(user_message: str) -> None:
    """
    For any agent invocation with a new session, the agent should still
    be invoked successfully and return a response.
    
    Validates: Handling of new conversations
    """
    with patch('app.event_planning.agent_invoker.invoke_agent_streaming') as mock_streaming:
        # Mock streaming response
        mock_streaming.return_value = iter([{'type': 'text', 'content': 'Response to first message'}])
        
        # Create a mock agent
        mock_agent = Mock()
        
        # Invoke agent with new session
        response = invoke_agent(mock_agent, user_message, session_id="new_session")
        
        # Verify streaming was called
        mock_streaming.assert_called_once()
        
        # Verify response is returned
        assert response == "Response to first message"


# Additional property test: Streaming completeness
@given(
    st.text(min_size=1, max_size=200),
    st.text(min_size=1, max_size=50).filter(lambda x: len(x.strip()) > 0)
)
@settings(max_examples=100)
def test_property_streaming_completeness(
    response_text: str,
    session_id: str
) -> None:
    """
    For any streaming response, all tokens should be yielded and the complete
    response should be reconstructable from the stream.
    
    Validates: Streaming response completeness
    """
    with patch('app.event_planning.agent_invoker._session_service') as mock_session_service, \
         patch('app.event_planning.agent_invoker.Runner') as mock_runner_class:
        
        # Mock session
        mock_session = Mock()
        mock_session.id = session_id
        mock_session_service.get_session_sync.return_value = mock_session
        
        # Create mock events with accumulated text (how ADK actually works)
        mock_events = []
        accumulated = ""
        for char in response_text:
            accumulated += char
            mock_event = Mock()
            mock_event.content = Mock()
            mock_part = Mock()
            mock_part.text = accumulated  # ADK sends accumulated text
            mock_event.content.parts = [mock_part]
            mock_event.function_calls = None
            mock_events.append(mock_event)
        
        # Mock runner
        mock_runner = Mock()
        mock_runner.run.return_value = iter(mock_events)
        mock_runner_class.return_value = mock_runner
        
        # Create a mock agent
        mock_agent = Mock()
        
        # Collect all streamed items
        streamed_items = list(invoke_agent_streaming(
            mock_agent,
            "Test message",
            session_id=session_id
        ))
        
        # Extract text tokens
        streamed_tokens = [item['content'] for item in streamed_items if item['type'] == 'text']
        
        # Verify all tokens were yielded
        assert len(streamed_tokens) > 0
        
        # Verify complete response can be reconstructed
        reconstructed = "".join(streamed_tokens)
        assert reconstructed == response_text


# Additional property test: Consistent responses
@given(
    st.text(min_size=1, max_size=100),
    st.text(min_size=1, max_size=50).filter(lambda x: len(x.strip()) > 0)
)
@settings(max_examples=100)
def test_property_consistent_responses(
    user_message: str,
    session_id: str
) -> None:
    """
    For any agent invocation, both streaming and non-streaming methods should
    produce the same final response content.
    
    Validates: Consistency between invocation methods
    """
    with patch('app.event_planning.agent_invoker.invoke_agent_streaming') as mock_streaming:
        # Mock streaming response
        response_text = "Consistent test response"
        mock_streaming.return_value = iter([{'type': 'text', 'content': response_text}])
        
        # Create mock agent
        mock_agent = Mock()
        
        # Get non-streaming response (uses streaming internally)
        complete_response = invoke_agent(mock_agent, user_message, session_id=session_id)
        
        # Verify response matches expected
        assert complete_response == response_text


# Feature: playground-fix, Property 15: Session ID consistency
@given(
    st.text(min_size=1, max_size=100),
    st.text(min_size=1, max_size=50).filter(lambda x: len(x.strip()) > 0),
    st.lists(st.text(min_size=1, max_size=100), min_size=2, max_size=5)
)
@settings(max_examples=100)
def test_property_15_session_id_consistency(
    session_id: str,
    user_id: str,
    messages: List[str]
) -> None:
    """
    Feature: playground-fix, Property 15: Session ID consistency
    
    For any conversation session, all messages should use the same session ID throughout.
    
    Validates: Requirements 7.2
    """
    with patch('app.event_planning.agent_invoker._session_service') as mock_session_service, \
         patch('app.event_planning.agent_invoker.Runner') as mock_runner_class:
        
        # Mock session
        mock_session = Mock()
        mock_session.id = session_id
        mock_session_service.get_session_sync.return_value = mock_session
        
        # Track all session IDs used in runner.run calls
        session_ids_used = []
        
        def mock_run(**kwargs):
            session_ids_used.append(kwargs.get('session_id'))
            # Return empty iterator
            return iter([])
        
        # Mock runner
        mock_runner = Mock()
        mock_runner.run = mock_run
        mock_runner_class.return_value = mock_runner
        
        # Create mock agent
        mock_agent = Mock()
        
        # Send multiple messages in the same session
        for message in messages:
            list(invoke_agent_streaming(
                mock_agent,
                message,
                session_id=session_id,
                user_id=user_id
            ))
        
        # Verify all invocations used the same session ID
        assert len(session_ids_used) == len(messages)
        assert all(sid == session_id for sid in session_ids_used), \
            f"Session IDs should be consistent: {session_ids_used}"


# Feature: playground-fix, Property 6: History availability to agent
@given(
    st.text(min_size=1, max_size=50).filter(lambda x: len(x.strip()) > 0),
    st.text(min_size=1, max_size=50).filter(lambda x: len(x.strip()) > 0),
    st.text(min_size=1, max_size=100)
)
@settings(max_examples=100)
def test_property_6_history_availability_to_agent(
    session_id: str,
    user_id: str,
    user_message: str
) -> None:
    """
    Feature: playground-fix, Property 6: History availability to agent
    
    For any message stored in the ADK session service, that message should be
    available in the context provided to the agent.
    
    Validates: Requirements 2.5
    """
    with patch('app.event_planning.agent_invoker._session_service') as mock_session_service, \
         patch('app.event_planning.agent_invoker.Runner') as mock_runner_class:
        
        # Mock session
        mock_session = Mock()
        mock_session.id = session_id
        mock_session_service.get_session_sync.return_value = mock_session
        
        # Track runner initialization to verify session service is passed
        runner_init_calls = []
        
        def mock_runner_init(*args, **kwargs):
            runner_init_calls.append(kwargs)
            mock_runner = Mock()
            mock_runner.run.return_value = iter([])
            return mock_runner
        
        mock_runner_class.side_effect = mock_runner_init
        
        # Create mock agent
        mock_agent = Mock()
        
        # Invoke agent
        list(invoke_agent_streaming(
            mock_agent,
            user_message,
            session_id=session_id,
            user_id=user_id
        ))
        
        # Verify Runner was initialized with the session service
        assert len(runner_init_calls) == 1
        assert 'session_service' in runner_init_calls[0]
        assert runner_init_calls[0]['session_service'] == mock_session_service
        
        # Verify the session service is the same one that stores messages
        # This ensures that messages stored in the session service are available to the agent
        assert runner_init_calls[0]['session_service'] is mock_session_service
